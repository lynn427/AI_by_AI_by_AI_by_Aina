import discord
from discord.ext import commands, tasks
from discord.ext import audiorec
import os
import asyncio
import tempfile
import whisper
import requests
import numpy as np
import soundfile as sf
from kokoro import KPipeline

# --- Setup Whisper STT
whisper_model = whisper.load_model("tiny")  # "tiny" or "base" for faster response

# --- Setup Kokoro TTS
tts_pipeline = KPipeline(lang_code='a')  # Adjust language if needed
DEFAULT_TTS_VOICE = "af_heart"

# --- Discord Bot Setup
intents = discord.Intents.default()
intents.voice_states = True
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)

active_recorders = {}  # Track voice connections by guild ID
cooldowns = {}  # Prevent spam responses

# --- Utility: Query Ollama
def query_ollama(prompt: str, model: str = "llama3") -> str:
    resp = requests.post(
        "http://localhost:11434/api/generate",
        json={"model": model, "prompt": prompt, "stream": False}
    )
    if resp.status_code == 200:
        return resp.json().get("response", "")
    return f"[error: Ollama status {resp.status_code}]"

# --- Utility: TTS with Kokoro
def tts_kokoro_to_file(text: str, output_wav_path: str, voice: str = DEFAULT_TTS_VOICE):
    generator = tts_pipeline(text, voice=voice)
    audio_segments = []
    sample_rate = 24000  # Kokoro default sample rate

    for (_, _, audio) in generator:
        audio_segments.append(audio)

    if not audio_segments:
        raise ValueError("No audio generated by Kokoro TTS")

    full_audio = np.concatenate(audio_segments, axis=0)
    sf.write(output_wav_path, full_audio, samplerate=sample_rate)

# --- Background Voice Monitoring
async def process_audio_chunk(vc: discord.VoiceClient, guild_id: int):
    """Continuously capture voice and respond automatically."""
    recorder = active_recorders[guild_id]
    while vc.is_connected():
        if recorder.audio_data:
            # Save current chunk to WAV
            with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as temp_file:
                temp_file.write(recorder.audio_data)
                audio_path = temp_file.name
            recorder.audio_data = b""  # Reset buffer

            # --- Whisper STT
            stt_result = whisper_model.transcribe(audio_path)
            user_text = stt_result.get("text", "").strip()

            if user_text:
                print(f"[STT] {user_text}")

                # Check cooldown
                now = asyncio.get_event_loop().time()
                if guild_id in cooldowns and now - cooldowns[guild_id] < 5:
                    os.remove(audio_path)
                    continue  # Skip if on cooldown
                cooldowns[guild_id] = now

                # --- Query Ollama
                response = query_ollama(user_text)
                print(f"[Ollama] {response}")

                # --- Generate Kokoro TTS
                with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as tts_file:
                    tts_path = tts_file.name
                tts_kokoro_to_file(response, tts_path)

                # --- Play TTS
                if not vc.is_playing():
                    source = discord.FFmpegPCMAudio(tts_path)
                    vc.play(source)
                    while vc.is_playing():
                        await asyncio.sleep(1)
                    os.remove(tts_path)

            os.remove(audio_path)
        else:
            await asyncio.sleep(0.5)  # Avoid busy waiting

# --- Join VC and start auto-capture
@bot.command()
async def join(ctx):
    """Bot joins the voice channel and starts listening automatically."""
    if not ctx.author.voice:
        await ctx.send("âŒ You need to be in a voice channel first.")
        return

    vc = await ctx.author.voice.channel.connect()
    recorder = audiorec.Recorder(vc)
    await recorder.start()
    active_recorders[ctx.guild.id] = recorder

    await ctx.send("ðŸŽ™ Listening to the channel automatically...")

    # Start background listening loop
    bot.loop.create_task(process_audio_chunk(vc, ctx.guild.id))

# --- Leave VC
@bot.command()
async def leave(ctx):
    """Bot leaves the voice channel and stops listening."""
    if ctx.guild.id in active_recorders:
        recorder = active_recorders.pop(ctx.guild.id)
        await recorder.stop()

    if ctx.voice_client:
        await ctx.voice_client.disconnect()
        await ctx.send("ðŸ‘‹ Stopped listening and left the channel.")
    else:
        await ctx.send("âš  I'm not in a voice channel.")

# --- Run the Bot
bot.run("YOUR_DISCORD_BOT_TOKEN")
